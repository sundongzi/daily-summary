##### 网络

网络地址：https://auth.antiy.cn:8000/

账号：23080103b

密码：Sd1996129&SUNDONG



##### 706环境

账户名：admin

密码：1qaz@wsx



##### gitlab项目克隆

项目token：master-2BctE62L_xULymKQLyE6     master-QbQhzbKmhvmdY89nSFpG



##### 项目Node版本：

14~15版本之间

##### 邮箱

账号：sundong@antiy.cn

密码：Sd1996129&SUNDONG







```
// 拦截重复请求
// import axios from "./axiosPrevent";
import axios from "axios";
import qs from "qs";
import { Message } from "element-ui";
import config from "@/config";
import store from "@/store";
import router from "@/router/control";
import { createHeaders } from "@/utils/util";
import { LOGIN_OUT_CODES } from "@/utils/enume";
// import vm from "../../main";
const mimeMap = {
  xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  zip: "application/x-zip-compressed",
  txt: "text/plain",
  json: "text/plain",
  doc: "application/msword",
  exe: "application/octet-stream",
};
const getType = (str) => {
  let keys = Object.keys(mimeMap);
  console.log(keys);
  for (let i = 0; i < keys.length; i++) {
    if (str.lastIndexOf(`.${keys[i]}`) !== -1) {
      return mimeMap[keys[i]];
    }
  }
};
// 错误提示
const errMsg = (message) => {
  Message.closeAll();
  const headers = createHeaders({});
  Message({
    type: "error",
    message,
  });
};
//登录失效以后，重复弹出提示的问题
let timer = 0;
let setLogout = (message) => {
  errMsg(message);
  timer++;
};
// 判断http响应码
const checkStatus = (res = {}) => {
  const { status, data } = res;
  if (status >= 200 && status < 300) {
    if (data.status && LOGIN_OUT_CODES.includes(data.status)) {
      // 清空store缓存数据
      store.state.riskDiscovery.info = "host";
      store.state.linuxHost.info = "";
      store.state.windowsHost.info = "";
      store.state.navtit = "";
      store.state.subnavtit = "";
      store.state.fourLevelNavigation = "";
      // 用户token过期等原因退出登录
      setLogout("登录过期，请重新登录");
      sessionStorage.clear();
      router.push("/login");
      // window.location.reload();
      if (timer > 1) {
        setTimeout(() => {
          setLogout = function () {};
        });
      }
      data.message = "登录过期，请重新登录";
      return data;
    } else {
      return !res.headers["content-disposition"]
        ? data
        : { "content-disposition": res.headers["content-disposition"], data };
    }
  } else {
    // 其他异常状态码
    errMsg(res);
  }
};

/**
 * 接口请求
 * @param  {string} method       请求方法
 * @param  {string} url          接口地址
 * @param  {object} params         请求参数
 * @param  {String} responseType 接口响应类型
 * @return {*}                   接口返回的参数
 */
// @FIXME:建议传参超过两个使用对象形式传参
const request = function ({ url, params:data = {}, method = 'get', responseType = '', tag } = {}) {
  url = responseType === 'text' ? url : `${config.baseUrl}${url}`;
  const headers = createHeaders(data);
  // 当请求为非上传类型时，设置Content-Type
  if (!(data instanceof FormData)) {
    headers["Content-Type"] = "application/json; charset=UTF-8";
  }
  if (data instanceof FormData) {
    //上传时
    headers["Content-Type"] = "multipart/form-data; charset=UTF-8";
  }
  let urlArr = url.split("/");
  if (urlArr.includes("download") || urlArr.includes("export")) {
    responseType = "blob";
  }
  if (method === "post" && !(data instanceof FormData)) {
    // post请求设置参数，让后端统一接收对象键值对格式：1.最外层都统一序列化； 2.个别接口还得单独序列化data内的复杂类型参数，希望后端能处理下
    data = typeof data === "object" ? JSON.stringify(data) : data; // 暂定这样传递，前后端统一后再做修改
  } else {
    // get请求设置参数
    url = data ? `${url}?${qs.stringify(data)}` : url;
  }
  // 请求前增加loading 依赖elementUI
  if (tag && this.loading) {
    this.$set(this.loading, tag, true)
  }
  return new Promise((resolve, reject) => {
    axios({
      method: method,
      url: url,
      data: data,
      headers: headers,
      responseType,
    })
      .then(checkStatus)
      .then((res) => {
        // 接口响应类型是文本的，直接返回数据
        if (responseType === 'text') {
          return resolve(res)
        }
        const { data, status, msg, message } = res;
        if (status === 0) {
          // 接口返回正常
          resolve(data);
        } else if (
          data &&
          status === undefined &&
          msg === undefined &&
          message === undefined
        ) {
          // if (vm.$loadingInstance) {
          //   vm.$loadingInstance.close();
          // }
          Message({
            type: "success",
            message: "下载成功!",
          });
          let type = getType(res["content-disposition"]) || "/";
          let filename = "";
          if (res["content-disposition"].split("utf-8''").length > 1) {
            filename = decodeURI(
              res["content-disposition"].split("utf-8''")[1].split(".")[0]
            );
          } else if (res["content-disposition"].split("filename=").length > 1) {
            let name = res["content-disposition"].split("filename=")[1];
            if (name.lastIndexOf("json") !== -1) {
              filename = decodeURI(name);
            } else {
              filename = decodeURI(name.split(".")[0]);
            }
          } else {
            console.error("下载错误!!");
          }
          console.log("type:::", type, filename);
          let blob = new Blob([res.data], {
            type,
          });
          let link = document.createElement("a");
          link.style.display = "none";
          link.href = URL.createObjectURL(blob);
          if (type === "application/octet-stream") {
            link.download = filename + ".exe"; //下载的文件名
          } else {
            link.download = filename; //下载的文件名
          }
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        } else {
          // 接口返回异常
          errMsg(message || msg || "接口异常");
          reject("error");
          // resolve(res)//一些问题反馈无法拿到
        }
      })
      .catch((err) => {
        errMsg(err);
        reject(err);
      }).finally(() => {
        if (tag && this.loading) {
          this.$set(this.loading, tag, false)
        }
      })
  });
};
export default request

```

