##### 工作

1. 威胁检测/威胁告警模块【request请求 && 局部loading加载 && 按钮防抖】添加完成

##### 学习

[什么,你还不会用指令解决文本的溢出提示?](https://juejin.cn/post/7255651765038596151#comment)

```javascript
import Popper from 'element-ui/src/utils/vue-popper'
import debounce from 'throttle-debounce/debounce'
import { addClass, removeClass, on, off } from 'element-ui/src/utils/dom'
import { generateId } from 'element-ui/src/utils/util'
import Vue from 'vue'

export default {
  name: 'TooltipWrapper',

  mixins: [Popper],

  props: {
    openDelay: {
      type: Number,
      default: 0
    },
    disabled: Boolean,
    manual: Boolean,
    effect: {
      type: String,
      default: 'dark'
    },
    arrowOffset: {
      type: Number,
      default: 0
    },
    popperClass: String,
    content: String,
    visibleArrow: {
      default: true
    },
    transition: {
      type: String,
      default: 'el-fade-in-linear'
    },
    popperOptions: {
      default () {
        return {
          boundariesPadding: 10,
          gpuAcceleration: false
        }
      }
    },
    enterable: {
      type: Boolean,
      default: true
    },
    hideAfter: {
      type: Number,
      default: 0
    },
    tabindex: {
      type: Number,
      default: 0
    }
  },

  data () {
    return {
      tooltipId: `el-tooltip-${generateId()}`,
      timeoutPending: null,
      focusing: false
    }
  },
  beforeCreate () {
    if (this.$isServer) return

    this.popperVM = new Vue({
      data: { node: '' },
      render (h) {
        return this.node
      }
    }).$mount()

    this.debounceClose = debounce(200, () => this.handleClosePopper())
  },

  render (h) {
    if (this.popperVM) {
      this.popperVM.node = (
        <transition
          name={ this.transition }
          onAfterLeave={ this.doDestroy }>
          <div
            onMouseleave={ () => { this.setExpectedState(false); this.debounceClose() } }
            onMouseenter= { () => { this.setExpectedState(true) } }
            ref="popper"
            role="tooltip"
            id={this.tooltipId}
            aria-hidden={ (this.disabled || !this.showPopper) ? 'true' : 'false' }
            v-show={!this.disabled && this.showPopper}
            class={
              ['el-tooltip__popper', 'is-' + this.effect, this.popperClass]
            }>
            { this.$slots.content || this.content }
          </div>
        </transition>)
    }

    const firstElement = this.getFirstElement()
    if (!firstElement) return null

    const data = firstElement.data = firstElement.data || {}
    data.staticClass = this.addTooltipClass(data.staticClass)

    return firstElement
  },
  watch: {
    focusing (val) {
      if (val) {
        addClass(this.referenceElm, 'focusing')
      } else {
        removeClass(this.referenceElm, 'focusing')
      }
    }
  },
  methods: {
    // 挂载目标节点
    setEl (el) {
      this.target = el
    },
    setContent (content) {
      this.content = content
    },
    init () {
      this.referenceElm = this.target
      if (this.target.nodeType === 1) {
        this.target.setAttribute('aria-describedby', this.tooltipId)
        this.target.setAttribute('tabindex', this.tabindex)
        on(this.referenceElm, 'mouseenter', this.show)
        on(this.referenceElm, 'mouseleave', this.hide)
        on(this.referenceElm, 'focus', () => {
          if (!this.$slots.default || !this.$slots.default.length) {
            this.handleFocus()
            return
          }
          const instance = this.$slots.default[0].componentInstance
          if (instance && instance.focus) {
            instance.focus()
          } else {
            this.handleFocus()
          }
        })
        on(this.referenceElm, 'blur', this.handleBlur)
        on(this.referenceElm, 'click', this.removeFocusing)
      }
      // fix issue https://github.com/ElemeFE/element/issues/14424
      if (this.value && this.popperVM) {
        this.popperVM.$nextTick(() => {
          if (this.value) {
            this.updatePopper()
          }
        })
      }
    },
    show () {
      this.setExpectedState(true)
      this.handleShowPopper()
    },

    hide () {
      this.setExpectedState(false)
      this.debounceClose()
    },
    handleFocus () {
      this.focusing = true
      this.show()
    },
    handleBlur () {
      this.focusing = false
      this.hide()
    },
    removeFocusing () {
      this.focusing = false
    },

    addTooltipClass (prev) {
      if (!prev) {
        return 'el-tooltip'
      } else {
        return 'el-tooltip ' + prev.replace('el-tooltip', '')
      }
    },

    handleShowPopper () {
      if (!this.expectedState || this.manual) return
      clearTimeout(this.timeout)
      this.timeout = setTimeout(() => {
        this.showPopper = true
      }, this.openDelay)

      if (this.hideAfter > 0) {
        this.timeoutPending = setTimeout(() => {
          this.showPopper = false
        }, this.hideAfter)
      }
    },

    handleClosePopper () {
      if (this.enterable && this.expectedState || this.manual) return
      clearTimeout(this.timeout)

      if (this.timeoutPending) {
        clearTimeout(this.timeoutPending)
      }
      this.showPopper = false

      if (this.disabled) {
        this.doDestroy()
      }
    },

    setExpectedState (expectedState) {
      if (expectedState === false) {
        clearTimeout(this.timeoutPending)
      }
      this.expectedState = expectedState
    },

    getFirstElement () {
      if (this.slotEl) return this.slotEl
      const slots = this.$slots.default
      if (!Array.isArray(slots)) return null
      let element = null
      for (let index = 0; index < slots.length; index++) {
        if (slots[index] && slots[index].tag) {
          element = slots[index]
        }
      }
      return element
    },
    unMount () {
      if (this.popperVM) {
        this.popperVM.$destroy() // 销毁 popperVM 实例
        this.popperVM.node && this.popperVM.node.elm.remove() // 移除对应的 tooltip节点
      }
      const reference = this.referenceElm
      // 解绑事件
      if (reference.nodeType === 1) {
        off(reference, 'mouseenter', this.show)
        off(reference, 'mouseleave', this.hide)
        off(reference, 'focus', this.handleFocus)
        off(reference, 'blur', this.handleBlur)
        off(reference, 'click', this.removeFocusing)
      }

      this.$nextTick(() => {
        this.doDestroy() // 调用 mixins的 Popper.doDestroy 销毁 popper
      })
    }
  },

  beforeDestroy () {
    this.popperVM && this.popperVM.$destroy()
  },

  destroyed () {
    const reference = this.referenceElm
    if (reference.nodeType === 1) {
      off(reference, 'mouseenter', this.show)
      off(reference, 'mouseleave', this.hide)
      off(reference, 'focus', this.handleFocus)
      off(reference, 'blur', this.handleBlur)
      off(reference, 'click', this.removeFocusing)
    }
  }
}

```



```javascript
import Vue from 'vue'
import Tooltip from './main'
const vmMap = new WeakMap()
const listenerMap = new WeakMap()
function getElStyleAttr (element, attr) {
  const styles = window.getComputedStyle(element)
  return styles[attr]
}
const isOverflow = (target) => {
  const scrollWidth = target.scrollWidth
  const offsetWidth = target.offsetWidth
  const range = document.createRange()
  range.setStart(target, 0)
  range.setEnd(target, target.childNodes.length)
  const rangeWidth = range.getBoundingClientRect().width
  const padding = (parseInt(getElStyleAttr(target, 'paddingLeft'), 10) || 0) + (parseInt(getElStyleAttr(target, 'paddingRight'), 10) || 0)
  return (rangeWidth + padding > target.offsetWidth) || scrollWidth > offsetWidth
}
export const ellipsisTooltip = {
  bind (el, binding, vnode, oldVnode) {
    const { value: { placement, disabled, content, effect, destroyOnLeave } = {} } = binding
    if (disabled) return
    // 加上超出...样式
    el.style.overflow = 'hidden'
    el.style.textOverflow = 'ellipsis'
    el.style.whiteSpace = 'nowrap'

    const onMouseLeave = () => {
      const elVm = vmMap.get(el)
      if (!elVm) return
      elVm.disabled = true
      elVm.$nextTick(elVm.unMount)
      vmMap.set(el, null)
    }
    const onMouseEnter = (e) => {
      const elVm = vmMap.get(el)
      // 需要展示
      if (isOverflow(el)) {
        if (elVm) {
          elVm.disabled = false
          return
        }
        const vm = new Vue(Tooltip).$mount()
        vm.placement = placement || 'top-start'
        vm.effect = effect || 'dark'
        vm.setEl(el)
        vm.setContent(content || el.innerText)
        vm.init()
        vm.show()
        vmMap.set(el, vm)
        if (destroyOnLeave) el.addEventListener('mouseleave', onMouseLeave)
      } else {
        if (elVm) elVm.disabled = true
      }
    }
    listenerMap.set(el, [
      ['mouseenter', onMouseEnter]
    ]) // 用于拓展后续的监听

    el.addEventListener('mouseenter', onMouseEnter)
  },
  unbind (el) {
    const events = listenerMap.get(el)
    if (events?.length) {
      events.forEach(([name, event]) => el.removeEventListener(name, event))
    }
  }
}

```

