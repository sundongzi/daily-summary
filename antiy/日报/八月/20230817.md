##### 总体原则

1. request入参修改
2. loading添加
   - 全局声明loading变量对象：业务中需要单独声明计算属性（不推荐）
   - loading的调用方式
     - v-loading指令的方式（推荐）
     - 通过现有服务方法，this.$openLoading
   - 局部loading：首先所有的请求方式不应该绑定在原型上，把`request`方法绑定到原型上；同时api文件夹中请求方法的使用方式需要改变（目前无法获取this组件实例），目前想到以下三种方式：
     - 通过call传递this
     - 通过mixins方式引入
     - import方法导入，先绑定到`methods`中，然后通过this.方法调用（推荐）

##### 具体修改

loading的使用方式由原本的服务方式（Loading.service）修改为指令方式（v-loading），项目中原有的全局loading（`$openLoading`）可以删除了。

1. api文件夹中的各个请求方法

   - 不在单独引入`request`，把`request`挂载到了`Vue`原型上，可以直接使用`this.$request`

   - reuqest传参方式修改，由原本的`枚举传参`修改为`对象传参`
   - 原本的箭头函数修改为`普通函数`，为了获取组件实例`this`，从而获取到组件中的`loading`对象

   ```javascript
   // 原有写法：
   import request from "@/utils/request";
   export const getClusterSelects = (params) => {
     request('console/container/base/label/info/get', params, 'get')
   }
   
   // 修改后的写法：
   export const getClusterSelects = function (params) {
     return this.$request({ url: 'console/container/base/label/info/get', params, method: 'get',  tag: 'aa' })
   }
   ```

2. 页面中使用

   - 请求方法的调用由原本直接从原型变量$http上面获取修改为单独引入
   - 由于需要当前组件this实例，因此调用请求方法时需要传递this（目前有三种方式）

   ```javascript
   // 原有写法，全局loading
   const rLoading = this.$openLoading();
   this.$http.getClusterSelects(params).then((res) => {
     ...
     rLoading.close()
   })
   
   // 修改后的写法
   <div v-loading="loading['aa']"></div>  // 此处的变量名称需要与请求方法中出入的tag变量名称保持一致
   // 引入请求方法
   import { getClusterSelects } from '@/api/utils/xxxx.js'
   export default {
     data () {
       return {
         // 声明loading变量对象
         this.loading: {}
       }
     },
     methods: {
       // 第一种方式
       getClusterSelects.call(this, params).then()
       
       // 第二种把原本请求方法的js文件进行修改导出方式，然后通过mixins引入到页面中
       
       // 建议使用第三种方式，先在methods中声明，然后在调用
       getClusterSelects,
       this.getClusterSelects(params).then()
     }
   }
   ```

上述修改由于涉及的文件比较多，因此建议可以把`eslint`打开，一起修改。



##### 学习

1. 定时器封装，可以用于想在定时器执行之前取消定时器的场景

   ```javascript
   function onTimeout(timeout, handler) {
     const timeoutId = setTimeout(handler, timeout)
     return () => clearTimeout(timeoutId)
   }
   
   const cancelTimeout = onTimeout(1000, () => {
     console.log('我是定时器，我要执行了')
   })
   
   // 如果想在定时器执行之前取消定时器
   cancelTimeout()
   ```

2. echarts图表封装

   [vue3中echarts组件的最佳封装形式](https://juejin.cn/post/7166138926728478733?searchId=20230817164258D79A22E285233F0CF4C6#heading-8)

   - vue2中如果数据量大了可能存在性能问题，图表options层级太深，每个属性都会绑定响应式。