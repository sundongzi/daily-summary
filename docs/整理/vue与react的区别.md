##### 数据管理

虽然都是数据驱动，但`Vue`是响应式的，而`React`需要手动`setState`

`Vue`是对数据进行劫持/代理，对监测数据的变化更加准确，动了多少数据就会触发多少更新，更新粒度很小。但是它也并没有那么完美，既然是监测数据，就需要对每个组件配置监听器，管理依赖和派发更新，这样同样也会影响性能。

`React`则是推崇函数式，这是没有办法感知数据变化的，因此不知道什么时候该刷新，而且即便是手动`setState`触发更新，也不知道哪些组件需要手动更新。因此它是渲染整个`DOM`，这就导致性能不好，所以后面只能不断优化无脑刷新的性能。比如：`React`增加了一个个避免刷新的钩子函数或者`API`，还有采用`Fiber`的架构来做时间分片也是来优化渲染的性能。

##### Diff算法

- `Vue2`是同层比较新老`vnode`，新的不存在老的存在就删除，新的存在老的不存在就创建，子节点采用双指针头对尾两端对比的方式，全量`diff`，然后移动节点时通过`splice`进行数组操作
- `Vue3`是采用`Map`数据结构以及动静结合的方式，在编译阶段提前标记静态节点，`Diff`过程中直接跳过有静态标记的节点，并且子节点对比会使用一个`source`数组来记录节点位置及最长递增子序列算法优化了对比流程，快速`Diff`，需要处理的边际条件会更少
- `React`是递归同层比较，标识差异点保存到`Diff`队列保存，得到`patch`树，再统一操作批量更新`DOM`

##### hooks区别

React:

- 定义：在React中，hooks是一系列以"use"作为开头的方法，它们提供了让你可以完全避开class式写法，在`函数式组件`中完成生命周期、状态管理、逻辑复用等几乎全部组件开发工作的能力。
- 使用：只能在`函数组件`内使用hooks
- 实现方式：基于链表实现，每次组件被`render`的时候都会按顺序执行所有`hooks`，而且因为底层是`链表`，每个`hook`的`next`是指向下一个`hook`的，所以我们写代码不能在不同的`hooks`调用里面使用`条件判断/函数嵌套之类`的，因为这会导致执行顺序不对。

Vue：

- 定义：在Vue`组合式API`里面，以“use”作为开头的，一系列提供了组件复用、状态管理等开发能力的方法。
- 使用：只能在`setUp`生命周期内使用“hooks”，只会被注册调用一次，因为它声明在`setup`里，一次组件实例化只调用一次`setup`。
- 实现方式：基于响应式实现，不需要链表对`hooks`进行记录，而是直接对数据代理观察，但它不得不返回一个包装对象，通过`.value`获取。因为在JS里基础类型只有值，没有引用，或者说只存在栈里，使用完就无法回收了，无法跟踪后续变化。

##### 编译优化

`Vue`能够做到预编译优化，可以静态分析，在解析模板时能根据解析到的不同的标签、文本等分别执行对应的回调函数来构造`AST`。

`React`虽然`JSX`语法更加灵活，但也正是因为这样导致，每次重新渲染时需要递归调用`React.createElement`，无法从模板层面进行静态分析。

#### 参考链接

[【由浅到深】聊聊 Vue 和 React 的区别，看看你在哪个段位](https://juejin.cn/post/7238199999733088313)

[浅谈：为啥vue和react都选择了Hooks🏂？](https://juejin.cn/post/7066951709678895141)