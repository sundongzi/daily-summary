#### 标记清除

大致步骤如下：

- 垃圾收集器在运行时会给内存中的所有变量打上标记，如果内存中所有的对象都是垃圾，则标记为0
- 从根节点还是遍历，把不是垃圾节点的标记改为1
- 清理剩下所有标记为0的垃圾，销毁并回收它们所占用的内存空间
- 把所有内存中对象标记修改为0，等待下一轮垃圾回收

缺点：

- 通过标记清除算法进行清除以后，剩余的对象内存位置是不变的，会导致空闲内存空间是不连续的，也就是所谓的`内存碎片`。

<img src="/Users/sundong/Library/Application Support/typora-user-images/image-20230619142152801.png" alt="image-20230619142152801" style="zoom:50%;" />

- `分配速度慢`，如果要为新建对象分配内存，由于空闲内存是间断的、不连续的，因此需要对空闲内存进行遍历。虽然采取了一旦找到大于或等于新对象大小的内存地址就立即返回，但也存在最坏的情况就是，最后一块内存才是符合的，这样也相当于整体遍历了一遍。

#### 标记整理

相比标记清除的不同点在于：每当标记结束后，标记整理算法会将活着的对象向内存的一端移动，最后清理掉边界的内存。

<img src="/Users/sundong/Library/Application Support/typora-user-images/image-20230619142921996.png" alt="image-20230619142921996" style="zoom:50%;" />

#### 引用计数法

循环引用

需要一个计时器

#### 分代式垃圾回收

##### 新生代垃圾回收

原理：新生代对象是通过`Scavenge`算法进行垃圾回收，该方法的具体实现中，主要采用了一种复制式的方法即`Cheney`算法。`Cheney`算法把新生代的堆内存一分为二，分别是处于使用状态的空间即 `使用区` ，另一个是处于闲置状态的空间即 `空闲区。`

- Scavenge算法：
- Cheney算法

整体过程描述：

```
首先新生代分使用区和空闲区，当使用区快满了，就要开始GC了
然后开始对使用区做标记，标记后复制一份活动对象到空闲区（这里做了整理的操作，也就是排序，避免内存碎片）
再然后清除使用区数据对象，把原来的使用区改称空闲区，把原来的空闲区改成使用区，这样的话新使用区就是空的，继续存数据，当快存满了开始下一轮GC
再看第二轮GC，还是重复上面的步骤，先标记，再把活动对象从使用区复制到空闲区，这个时候假如发现了上次就存在的对象这次还是活动对象，那这个对象就会被晋级，扔到老生代里去。接着说复制之后，使用区又被清空了，并且再次和空闲区转换，那每一轮GC过后，使用区就会变成空的
```

如何提高回收效率？

并行回收

##### 老生代垃圾回收

老生代中的对象由于存活时间较长，垃圾回收的成本较高。

回收原理：

- 标记清除：首先标记出活跃的对象，然后清除未标记的对象
- 标记压缩（整理）：清除未标记的对象之后，将存活的对象压缩到内存的一端，从而减少内存碎片化。

如何提高回收效率？

增量标记：主要采用三色标记法，允许垃圾回收过程与程序执行交替进行，每次执行一小部分的标记操作，减少了垃圾回收对程序的中断时间。

##### 参考链接

[「硬核JS」你真的了解垃圾回收机制吗](https://juejin.cn/post/6981588276356317214#comment)